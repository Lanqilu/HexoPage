---
title: 数据的表示和运算
date: 2021-05-26 19:56:05
mathjax: true
highlight_shrink: true # 代码框是否展开
cover: https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-c@master/img/主板.5s03s46rav40.jpg # 页面缩略图
# large: true
bilibili_banner: false # autumn 、winter
tags: 计算机组成原理
categories: 计算机组成原理
---

## 数制与编码


在计算机系统内部，所有的信息都是用二进制进行编码的，这样做的原因有以下几点。
1. 二进制只有两种状态，使用有两个稳定状态的物理器件就可以表示二进制数的每一位，制造成本比较低，例如用高低电平或电荷的正负极性都可以很方便地表示 0 和 1。
2. 二进制位 1 和 0 正好与逻辑值“真”和“假”对应，为计算机实现逻辑运算和程序中的逻辑判断提供了便利条件。
3. 二进制的编码和运算规则都很简单，通过逻辑门电路能方便地实现算术运算。

### 进位计数法

进位计数法是一种计数的方法。常用的进位计数法有十进制、二进制、八进制、十六进制等。十进制数是日常生活中最常使用的，而计算机中通常使用二进制数、八进制数和十六进制数。

在进位计数法中，每个数位所用到的不同数码的个数称为基数。十进制的基数为 10（0 \~ 9），每个数位计满 10 就向高位进位，即“逢十进一”。十进制数 101，其个位的 1 显然与百位的 1 所表示的数值是不同的。每个数码所表示的数值等于该数码本身乘以一个与它所在数位有关的常数，这个常数称为位权。一个进位数的数值大小就是它的各位数码按权相加。

一个 $r$ 进制数（$K_{n} K_{n-1} \cdots K_{0} K_{-1} \cdots K_{-m}$）的数值可表示为：$$K_{n} r^{n}\+ K_{n-1} r^{n-1} \+ \cdots \+ K_{0} r^{0} \+ K_{-1} r^{-1} \+ \cdots \+ K_{-m} r^{-m} = \sum_{i=n}^{-m} K_{i} r^{i}$$式中，$r$ 是基数；$r^{i}$ 是第 $i$ 位的位权（整数位最低规定为第 0 位）；$K_{i}$ 的取值可以是 $0,1,\cdots,r-1$ 共 $r$ 个数码中的任意一个。

+ 二进制。计算机中用得最多的是基数为 2 的计数制，即二进制。二进制只有 0 和 1 两种数字符号，计数“逢二进一”。它的任意数位的权为 $2^{i}$，$i$ 为所在位数。
+ 八进制。八进制作为二进制的一种书写形式，其基数为 8，有 0 \~ 7 共 8 个不同的数字符号，计数“逢八进一”。因为 $r=8=2^{3}$，所以只要把二进制中的 3 位数码编为一组就是一位八进制数码，两者之间的转换极为方便。
+ 十六进制。十六进制也是二进制的一种常用书写形式，其基数为 16，“逢十六进一”。 每个数位可取 0 \~ 9、A、B、C、D、E、F 中的任意一个，其中 A、B、C、D、E、F 分别表示 10 \~ 15。因为 $r=16=2^{4}$，因此 4 位二进制数码与 1 位十六进制数码相对应。

### 不同进制数之间的相互转换

（1）二进制数转为八进制数和十六进制数

对于一个二进制混合数（既包含整数部分，又包含小数部分），在转换时应以小数点为界。

+ 其整数部分，从小数点开始往左数，将一串二进制数分为 3 位（八进制）一组或 4 位（十六进制）一组，在数的最左边可根据需要加“0”补齐；
+ 对于小数部分，从小数点开始往右数，也将一串二进制数分为 3 位一组或 4 位一组，在数的最右边也可根据需要加“0”补齐。最终使总的位数为 3 或 4 的整数倍，然后分别用对应的八进制数或十六进制数取代。

同样，由八进制数或十六进制数转换成二进制数， 只需将每位改为 3 位或 4 位二进制数即可（必要时去掉整数最高位或小数最低位的 0）。

八进制数和十六进制数之间的转换也能方便地实现，十六进数制转换为八进制数（或八进制数转换为十六进制数）时，先将十六进制（八进制）数转换为二进制数，然后由二进制数转换为八进制（十六进制）数较为方便。

（2）任意进制数转换为十进制数

将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。这种方法称为按权展开相加法。

（3）十进制数转换为任意进制数

一个十进制数转换为任意进制数，常采用基数乘除法。这种转换方法对十进制数的整数部分和小数部分将分别进行处理，对整数部分用除基取余法，对小数部分用乘基取整法，最后将整数部分与小数部分的转换结果拼接起来。

+ 除基取余法（整数部分的转换）：整数部分除基取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位（即除基取余，先余为低，后余为高），商为 0 时结束。
+ 乘基取整法（小数部分的转换）：小数部分乘基取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位（即乘基取整，先整为高，后整为低），乘积为 1.0 （或满足精度要求）时结束。

例如将十进制数 123.6875 转换成二进制数：

![十进制数转换为任意进制数](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/十进制数转换为任意进制数.png)

因此整数部分 123 = (1111011)<sub>2</sub> ，小数部分 0.6885 = (0.1011)<sub>2</sub> ，所以 123.6875 = (1111011.1011)<sub>2</sub> 

> 注意：在计算机中，小数和整数不一样，整数可以连续表示，但小数是离散的，所以并不是每个十进制小数都可以准确地用二进制表示。例如 0.3，无论经过多少次乘二取整转换都无法得到精确的结果。但任意一个二进制小数都可以用十进制小数表示。

### 真值和机器数

在日常生活中，通常用正号、负号来分别表示正数（正号可省略）和负数，如 +15、-8 等。这种带“+”或“-”符号的数称为真值。真值是机器数所代表的实际值。

在计算机中，通常采用数的符号和数值一起编码的方法来表示数据。常用的有原码、补码和反码表示法。这几种表示法都将数据的符号数字化，通常用“0”表示“正”，用“1”表示“负”。如 0,101 （这里的逗号“,”实际上并不存在，仅为区分符号位与数值位）表示 +5。这种把符号“数字化”的数称为机器数。

### BCD 码

二进制编码的十进制数（Binary-Coded Decimal, BCD）通常采用 4 位二进制数来表示一位十进制数中的 0 \~ 9 这 10 个数码。这种编码方法使二进制数和十进制数之间的转换得以快速进行。但 4 位二进制数可以组合出 16 种代码，因此必有 6 种状态为冗余状态。

下面列举几种常用的 BCD 码：

1. 8421 码（最常用）。它是一种有权码，设其各位的数值为 $b_{3}$，$b_{2}$，$b_{2}$，$b_{0}$，则权值从高到低依次为 8，4，2，1，它表示的十进制数为 $D= 8b_{3} +4b_{2} + 2b_{1}+ 1b_{0}$。如 8 → 1000；9 → 1001。若两个 8421 码相加之和小于等于 (1001)<sub>2</sub> 即 (9)<sub>10</sub>，则不需要修正；若相加之和大于等于 (1010)<sub>2</sub> 即 (10)<sub>10</sub>，则要加 6 修正（从 1010 到 1111 这 6 个为无效码，当运算结果落于这个区间时，需要将运算结果加上 6），并向高位进位，进位可以在首次相加或修正时产生。
  ![8421码修正](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/8421码修正.png)
2. 余 3 码。这是一种无权码，是在 8421 码的基础上加 (0011)<sub>2</sub> 形成的，因每个数都多余“3”，因此称为余 3 码。如 8 → 1011；9 → 1100。
3. 2421 码。这也是一种有权码，权值由高到低分别为 2，4，2，1，特点是大于等于 5 的 4 位二进制数中最高位为 1，小于 5 的最高位为 0。如 5 → 1011 而非 0101。

### 字符与字符串

由于计算机内部只能识别和处理二进制代码，所以字符都必须按照一定的规则用一组二进制编码来表示。

（1）字符编码 ASCII 码

目前，国际上普遍采用的一种字符系统是 7 位二进制编码的 ASCII 码，它可表示 10 个十进制数码、52 个英文大写字母和小写字母（A \~ Z, a \~ z）及一定数量的专用符号（如 $、%、+、= 等），共 128 个字符。

在 ASCII 码中，编码值 0 \~ 31 为控制字符，用于通信控制或设备的功能控制；编码值 127 是 DEL 码；编码值 32 是空格 SP；编码值 32 \~ 126 共 95 个字符称为可印刷字符。

> 提示: 0 \~ 9 的 ASCII 码值为 48 (011 0000) \~ 57 (011 1001)，即去掉高 3 位，只保留低 4 位，正好是二进制形式的 0 \~ 9。

（2）汉字的表示和编码

在 1981 年的国家标准 GB 2312——1980 中，每个编码用两字节表示，收录了一级汉字 3755 个、二级汉字 3008 个、各种符号 682 个，共计 7445 个。

目前最新的汉字编码是 2000 年公布的国家标准 GB 18030，它收录了 27484 个汉字。编码标准采用 1 B、2 B 和 4 B。

汉字的编码包括汉字的输入编码、汉字内码、汉字字形码三种，它们是计算机中用于输入、内部处理和输出三种用途的编码。区位码是国家标准局于 1981 年颁布的标准，它用两字节表示一个汉字，每字节用七位码，并将汉字和图形符号排列在一个 94 行 94 列的二维代码表中。区位码是 4 位十进制数，前 2 位是区码，后 2 位是位码，所以称为区位码。

国标码将十进制的区位码转换为十六进制数后，再在每字节上加上 20 H。国标码两字节的最高位都是 0，ASCII 码的最高位也是 0。为了方便计算机区分中文字符和英文字符，将国标码两字节的最高位都改为“1”，这就是汉字内码。

区位码和国标码都是输入码，它们和汉字内码的关系（十六进制）如下:

+ 国标码 = (区位码)<sub>16</sub> + 2020H
+ 汉字内码 = (国标码)<sub>16</sub> + 8080H

### 校验码

校验码是指能够发现或能够自动纠正错误的数据编码，也称检错纠错编码。校验码的原理是通过增加一些冗余码，来检验或纠错编码。

通常某种编码都由许多码字构成，任意两个合法码字之间最少变化的二进制位数，称为数据校验码的码距。对于码距不小于 2 的数据校验码，开始具有检错的能力。码距越大，检错、纠错的能力就越强，而且检错能力总是大于等于纠错能力。

#### 奇偶校验码

在原编码上加一个校验位，它的码距等于 2，可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能够检测出偶数位错误，增加的冗余位称为奇偶校验位。

奇偶校验实现的方法：由若干位有效信息（如 1 B）再加上一个二进制位（校验位）组成校验码。校验位的取值（0 或 1）将使整个校验码中“1”的个数为奇数或偶数，所以有两种可供选择的校验规律。

+ 奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数。
+ 偶校验码：整个校验码（有效信息位和校验位）中“1”的个数为偶数。

缺点：具有局限性，奇偶校验只能发现数据代码中奇数位的出错情况，但不能纠正错误，常用于对存储器数据的检查或传输数据的检查。

#### 海明校验码

海明码是广泛采用的一种有效的校验码，它实际上是一种多重奇偶校验码。其实现原理是在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，还能指出错位的位置，为自动纠错提供依据。根据纠错理论得：$$L- 1=D+C \ (D \ge C)$$即编码最小码距 $L$ 越大，其检测错误的位数 $D$ 越大，纠正错误的位数 $C$ 也越大，且纠错能力恒小于等于检错能力。海明码就是根据这一理论提出的具有纠错能力的一种编码。

下面用一个例子来介绍求海明码的步骤。在 $n=4$、$k=3$ 时，求 1010 的海明码。

（1）确定海明码的位数

设 $n$ 为有效信息的位数，$k$ 为校验位的位数，则信息位 $n$ 和校验位 $k$ 应满足 $$n+k \le 2^{k}-1$$ 若要检测两位错，则需再增加 1 位校验位，即 $k+1$ 位。海明码位数为 $n+k=7 \le 2^{3}-1$ 成立，则 $n$、$k$ 有效。

设信息位为 $D_{4} D_{3} D_{2} D_{1}$（1010），共 4 位，校验位为 $P_{3} P_{2} P_{1}$，共 3 位，对应的海明码为 $H_{7} H_{6} H_{5} H_{4} H_{3} H_{2} H_{1}$。

（2）确定校验位的分布

规定校验位 $P_i$ 在海明位号为 $2^{i-1}$ 的位置上，其余各位为信息位，因此有：

+ $P_1$ 的海明位号为 $2^{i-1} = 2^{0} = 1$，即 $H_1$ 为 $P_1$。
+ $P_2$ 的海明位号为 $2^{i-1} = 2^{1} = 2$，即 $H_2$ 为 $P_2$。
+ $P_3$ 的海明位号为 $2^{i-1} = 2^{2} = 4$，即 $H_4$ 为 $P_3$。

将信息位按原来的顺序插入，则海明码各位的分布如下: 
$$
\begin{matrix}
 H_{7}  & H_{6}  & H_{5}  & H_{4}  & H_{3}  & H_{2}  & H_{1} \\\\
 D_{4}  & D_{3}  & D_{2}  & P_{3}  & D_{1}  & P_{2}  & P_{1} 
\end{matrix}
$$

（3）分组以形成校验关系

每个数据位用多个校验位进行校验，但要满足条件：被校验数据位的海明位号等于校验该数据位的各校验位海明位号之和。另外，校验位不需要再被校验。分组形成的校验关系如下。

![海明码校验位](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/海明码校验位.png)

（4）校验位取值

校验位 $P_i$ 的值为第 $i$ 组（由该校验位校验的数据位）所有位求异或（如果两个值不相同，则异或结果为 1。如果两个值相同，异或结果为 0。）。由上分组有：

$$
\begin{align*}
P_{1}=D_{1} \oplus D_{2} \oplus D_{4} = 0 \oplus 1 \oplus 1 = 0 \\\\ 
P_{2}=D_{1} \oplus D_{3} \oplus D_{4} = 0 \oplus 0 \oplus 1 = 1 \\\\
P_{3}=D_{2} \oplus D_{3} \oplus D_{4} = 1 \oplus 0 \oplus 1 = 0
\end{align*}
$$

所以，1010 对应的海明码为 1010010

（5）海明码的校验原理

每个校验组分别利用校验位和参与形成该校验位的信息位进行奇偶校验检查，构成 $k$ 个校验方程：

$$
\begin{align*}
S_{1}=P_{1} \oplus D_{1} \oplus D_{2} \oplus D_{4} \\\\ 
S_{2}=P_{2} \oplus D_{1} \oplus D_{3} \oplus D_{4} \\\\
S_{3}=P_{3} \oplus D_{2} \oplus D_{3} \oplus D_{4} 
\end{align*}
$$

若 $S_{3}S_{2}S_{1} =000$，则说明无错；否则说明出错，且这个数就是错误的位号，如 $S_{3}S_{2}S_{1} = 001$，说明第 1 位出错，即 $H_{1}$ 出错，直接将该位取反就达到纠错的目的。

![海明码校验元素关系](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/海明码校验元素关系.png)

海明码的检错能力为 1 位，纠错能力为 2 位。通常使用时会在最头部加上“全校验位”，对整体进行偶校验：

+ $S_{3}S_{2}S_{1} =000$ 且全体偶校验成功，无错误
+ $S_{3}S_{2}S_{1} \ne 000$ 且全体偶校验失败，有 1 位错误，纠正即可
+ $S_{3}S_{2}S_{1} \ne 000$ 且全体偶校验成功，有 2 位称为，需重传

拓展：

{% link 【3Blue1Brown】汉明码Pa■t1，如何克服噪■, https://www.bilibili.com/video/BV1WK411N7kz, https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg %}

{% link 【3Blue1Brown】汉明码part2，优雅的全貌, https://www.bilibili.com/video/BV1pV411y7E8, https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/bilibiliIcon.svg %}

#### 循环冗余校验码

+ CRC 码的基本思想
+ 如何构造
+ 如何检错纠错
 
循环冗余校验（Cyclic Redundancy Check，CRC）码的基本思想是：在 $K$ 位信息码后再拼接 $R$ 位的校验码，整个编码的长度为 $N$ 位，因此，这种编码又称 $(N,K)$ 码。

+ 数据发送、接收方约定一个“除数”
+ $K$ 个信息位 + $R$ 个校验位作为“被除数”，添加校验位后需保证除法的余数为 0
+ 收到数据后，进行除法检查余数是否为 0，若余数非 0 说明出错，则进行重传或纠错

CRC 码基于线性编码理论，在发送端，将要传送的 $K$ 位二进制信息码左移 $R$ 位，将它与生成多项式 $G(x)$ 做模 2 除法，生成一个 $R$ 位校验码，并附在信息码后，构成一个新的二进制码（CRC 码），共 $K+R$ 位。在接收端，利用生成多项式对接收到的编码做模 2 除法，以检测和确定出错的位置，如无错则整除，其中生成多项式是接收端和发送端的一个约定。

任意一个二进制数码都可用一个系数仅为“ 0 ”或“ 1 ”的多项式与其对应。生成多项式 $G(x)$ 的最高幂次为 $R$，转换成对应的二进制数有 $R+1$ 位。例如，生成多项式 $x^{3} + x^{2} + 1$ 对应的二进制数为 1101，而二进制数 1011 对应的多项式为 $x^{3} + x^{2} + 1$ 。下面用一个例子来介绍 CRC 的编码和检测过程。

设生成多项式 $G(x) = x^{3} + x^{2} + 1$，信息码为 101001，求对应的 CRC 码

+ 生成多项式 $G(x) = 1x^{3} + 1x^{2} + 0x^{1} + 1x^{0}$，故对应的二进制码为 1101。
+ $R$ 等于生成多项式最高次幂，即为 3
+ $K$ 等于信息码长度，即为 6
+ 校验码位数 $N = K+R=9$

（1）位移

将原信息码左移 $R$ 位，低位补 0，得到 101001000

（2）相除

对位移后的信息码，用生成多项式进行模 2 除法，产生余数。

> 模 2 减法：和模 2 加法的结果相同，都是做异或运算
> 模 2 除法：模 2 除法和算术除法类似，但每位除（减）的结果不影响其他位，即不借位。

1. 用除数对被除数最高几位做模 2 减（异或），不借位。
2. 除数右移一位，若余数最高位为 1，商为 1，并对余数做模 2 减。若余数最高位为 0，商为 0，除数继续右移一位。
3. 循环直到余数位数小于除数时，该余数为最终余数。

![CRC码生成过程](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/CRC码生成过程.png)

模 2 除法过程如图上所示，得到余数为 001，则报文 101001 编码后的报文（即 CRC 码）为 101001001

（3）检错和纠错

接收端收到的 CRC 码，用生成多项式 $G(x)$ 做模 2 除法，若余数为 0，则码字无错。

若接收端收的 CRC 码为 $C_{9} C_{8} C_{7} C_{6} C_{5} C_{4} C_{3} C_{2} C_{1} = 101001011$，将这个数据与 1101 进行模 2 除法，得到的余数为 010，则说明 $C_{2}$ 出错（不一定正确），将 $C_{2}$ 取反即可。

> 注意：余数值与出错位置并不是二进制与十进制转换的关系。

![CRC码余数与出错位关系](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-b@master/img/CRC码余数与出错位关系.png)

$K$ 个信息位，$R$ 个校验位，若生成多项式选择得当，且 $2^{R} \ge K + R + 1$ ，则 CRC 码可纠正 1 位错。实际应用中一般只用来“检错”。

理论上可以证明循环冗余校验码的检错能力有以下特点：
1. 可检测出所有奇数个错误;
2. 可检测出所有双比特的错误;
3. 可检测出所有小于等于校验位长度的连续错误;

## 定点数的表示与运算



https://www.bilibili.com/video/BV1BE411D7ii?p=14